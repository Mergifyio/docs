---
title: Merge Queue
description: Ship faster with zero broken builds. Parallel testing, smart batching, and CI cost optimization.
---

import Button from '~/components/Button.astro';
import AcademyCallout from '~/components/AcademyCallout.astro';
import DocsetGrid from '~/components/DocsetGrid/DocsetGrid.astro';
import Docset from '~/components/DocsetGrid/Docset.astro';

export const Yes = ({children}) => (
  <span style={{color: 'var(--chakra-colors-green-500)', fontWeight: '600'}}>
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"
      style={{verticalAlign: 'middle', marginRight: '4px'}} aria-hidden="true">
      <polyline points="20 6 9 17 4 12"></polyline>
    </svg>
    {children}
  </span>
);

export const No = ({children}) => (
  <span style={{color: 'var(--chakra-colors-red-500)', fontWeight: '600'}}>
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none"
      stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"
      style={{verticalAlign: 'middle', marginRight: '4px'}} aria-hidden="true">
      <line x1="18" y1="6" x2="6" y2="18"></line>
      <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
    {children}
  </span>
);

<div style={{
  display: 'flex',
  flexWrap: 'wrap',
  gap: '1rem',
  margin: '1.5rem 0'
}}>
  <div style={{
    flex: '1 1 200px',
    padding: '1rem 1.25rem',
    borderRadius: '8px',
    background: 'var(--section-merge-queue-accent-bg)',
    borderLeft: '4px solid var(--section-merge-queue-accent)'
  }}>
    <div style={{
      fontSize: '1.5rem',
      fontWeight: 'bold',
      color: 'var(--section-merge-queue-accent)'
    }}>3-5x</div>
    <div style={{
      fontSize: '0.9rem',
      color: 'var(--theme-text-light)'
    }}>merge throughput</div>
  </div>
  <div style={{
    flex: '1 1 200px',
    padding: '1rem 1.25rem',
    borderRadius: '8px',
    background: 'var(--section-merge-queue-accent-bg)',
    borderLeft: '4px solid var(--section-merge-queue-accent)'
  }}>
    <div style={{
      fontSize: '1.5rem',
      fontWeight: 'bold',
      color: 'var(--section-merge-queue-accent)'
    }}>60-90%</div>
    <div style={{
      fontSize: '0.9rem',
      color: 'var(--theme-text-light)'
    }}>CI cost reduction</div>
  </div>
  <div style={{
    flex: '1 1 200px',
    padding: '1rem 1.25rem',
    borderRadius: '8px',
    background: 'var(--section-merge-queue-accent-bg)',
    borderLeft: '4px solid var(--section-merge-queue-accent)'
  }}>
    <div style={{
      fontSize: '1.5rem',
      fontWeight: 'bold',
      color: 'var(--section-merge-queue-accent)'
    }}>Zero</div>
    <div style={{
      fontSize: '0.9rem',
      color: 'var(--theme-text-light)'
    }}>broken builds</div>
  </div>
</div>

Stop wasting engineering time on merge conflicts and broken main branches.
Mergify's merge queue tests every PR against the latest code before merging,
while parallel execution and smart batching keep your team shipping fast.

<Button colorScheme="teal" href="/merge-queue/setup" target="_self">
  Get Started →
</Button>

<AcademyCallout>
  New to merge queues? Learn the fundamentals, failure scenarios, and best
  practices.
</AcademyCallout>

## Do You Need a Merge Queue?

If any of these sound familiar, a merge queue can help:

| Symptom | What's Happening | How Mergify Helps |
|---------|------------------|-------------------|
| PRs pass CI but break main | PRs tested against stale base | Tests every PR against latest main |
| Developers wait hours to merge | Serial merge bottleneck | Parallel speculative testing |
| CI bill keeps climbing | Full test suite on every PR | Batching + two-step CI |
| Monorepo PRs block each other | Unrelated changes queued together | Scoped queues for independent paths |
| Hotfixes stuck behind features | No priority mechanism | Priority rules for urgent PRs |

## What Mergify Solves

### Broken Main Branch

PRs that pass CI individually can break main when merged together. Mergify
updates each PR against the latest main and re-runs CI before merging—catching
conflicts before they hit production.

**→ [How the queue works](/merge-queue/lifecycle)**

### Slow Merge Throughput

Serial testing creates bottlenecks. Mergify tests multiple PRs in parallel
using speculative execution, so your queue moves as fast as your CI allows.

**→ [Parallel checks](/merge-queue/parallel-checks)**

### Spiraling CI Costs

Running full test suites on every PR is expensive. Mergify batches PRs together
into single CI runs and supports two-step CI to run heavy tests only at merge
time.

**→ [Batches](/merge-queue/batches) | [Two-step CI](/merge-queue/two-step)**

### Monorepo Complexity

Unrelated changes shouldn't block each other. Mergify uses scopes to identify
which services a PR affects and only batches compatible changes together.

**→ [Scopes](/merge-queue/scopes) | [Monorepo guide](/merge-queue/monorepo)**

## Key Features

| Feature | What It Does | Impact |
|---------|--------------|--------|
| [Parallel checks](/merge-queue/parallel-checks) | Test multiple PRs simultaneously | 3-5x faster merge throughput |
| [Batches](/merge-queue/batches) | Combine PRs into single CI runs | 50-80% fewer CI runs |
| [Two-step CI](/merge-queue/two-step) | Run heavy tests only at merge time | Cut CI costs on draft/WIP PRs |
| [Priority](/merge-queue/priority) | Let urgent PRs jump the queue | Ship hotfixes in minutes |
| [Scopes](/merge-queue/scopes) | Separate queues for monorepo paths | No cross-service blocking |
| [Pause](/merge-queue/pause) | Freeze merges during incidents | Instant incident response |

## Mergify vs GitHub Native Merge Queue

| Capability | GitHub Native | Mergify |
|------------|---------------|---------|
| Parallel speculative checks | <Yes>Up to 100</Yes> | <Yes>Up to 128</Yes> |
| Batch multiple PRs | <No /> | <Yes>Configurable size + CI optimization</Yes> |
| Priority queues | <No /> | <Yes>Label or rule-based</Yes> |
| Monorepo scopes | <No /> | <Yes>Path-based queues + Bazel/Nx integration</Yes> |
| Two-step CI | <No /> | <Yes>Draft CI + merge CI</Yes> |
| Pause/freeze queue | <No /> | <Yes>API + dashboard</Yes> |
| Cross-repo queues | <No /> | <Yes>Coordinate dependent repos</Yes> |
| Queue analytics | <No /> | <Yes>Wait times, throughput, failures</Yes> |

## Learn More

<DocsetGrid>
  <Docset title="For Engineering Managers" path="/merge-queue/performance" icon="mdi:chart-line">
    Track queue performance, monitor throughput metrics, and measure CI cost savings.
  </Docset>
  <Docset title="For DevOps & Platform" path="/merge-queue/setup" icon="mdi:cog">
    Configure queue rules, set up CI integration, and tune parallel check settings.
  </Docset>
  <Docset title="For Developers" path="/merge-queue/lifecycle" icon="mdi:source-pull">
    Understand PR lifecycle, queue behavior, and how to use priority labels.
  </Docset>
</DocsetGrid>

## Quick Reference

**Setup & Configuration**
[Setup guide](/merge-queue/setup) ·
[Queue rules](/merge-queue/rules) ·
[Freeze conditions](/merge-protections/freeze)

**Performance & Optimization**
[Performance tuning](/merge-queue/performance) ·
[Monitoring](/merge-queue/monitoring) ·
[Deployment strategies](/merge-queue/deploy)

**Advanced Features**
[Monorepo guide](/merge-queue/monorepo) ·
[Dependent PRs](/merge-protections/builtin)

**Operations**
[Pause queue](/merge-queue/pause) ·
[PR commands](/commands)
